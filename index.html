<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Primer-Style City: Agents + 3D Buildings</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --w: 900px; }
  body {
    margin: 0; background: #0f1115; color: #eaeef7; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display: grid; place-items: center; gap: 10px; padding: 14px;
  }
  h1 { margin: 0 0 4px; font-size: clamp(18px, 3.2vw, 26px); font-weight: 700; letter-spacing: .2px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 10px; width: min(95vw, var(--w)); }
  #sim { width: 100%; height: auto; border: 2px solid #2b3245; background: #161a22; border-radius: 8px; }
  #chart { width: 100%; height: 240px; background: #10141c; border: 2px solid #2b3245; border-radius: 8px; }
  .legend { font-size: 14px; opacity: .9; display:flex; gap:12px; flex-wrap:wrap; }
  .dot{display:inline-block;width:10px;height:10px;border-radius:50%;transform:translateY(1px)}
  .dot.h{background:lime}.dot.i{background:#ff4b4b}.dot.m{background:#4aa3ff}
  .meta { font-size: 12px; opacity: .8 }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Primer-Style City</h1>
  <div class="legend">
    <span><span class="dot h"></span> Healthy</span>
    <span><span class="dot i"></span> Infected</span>
    <span><span class="dot m"></span> Immune</span>
    <span class="meta">Agents walk to two buildings per day. 1% infection on shared-visit contact.</span>
  </div>
  <div class="row">
    <canvas id="sim" width="900" height="520"></canvas>
    <canvas id="chart" width="900" height="240"></canvas>
  </div>

<script>
/* ==========================
   Config
========================== */
const FRAMES_PER_SECOND = 60;                  // visual smoothness
const FRAMES_PER_DAY    = 300;                 // “simulation day” length
const WINDOWS_PER_DAY   = 2;                   // two visits/day
const WINDOW_FRAMES     = FRAMES_PER_DAY / 2;  // frames per visit window
const INFECT_CHANCE     = 0.01;                // 1%
const START_INFECTED    = 0.05;                // 5%
const SICK_DAYS         = 5;                   // infected -> immune
const IMMUNE_DAYS       = 3;                   // immune -> healthy
const SICK_FRAMES       = SICK_DAYS  * FRAMES_PER_DAY;
const IMMUNE_FRAMES     = IMMUNE_DAYS * FRAMES_PER_DAY;

const N_AGENTS = 80;
const CITY_PADDING = 60;
const AGENT_SPEED = 1.6;                       // px/frame
const ARRIVE_DIST = 8;                         // arrival radius
const DWELL_FRAMES = 80;                       // hang out when inside a building

/* ==========================
   Canvas & Utils
========================== */
const sim = document.getElementById('sim');
const ctx = sim.getContext('2d');

function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

/* ==========================
   Building (3D-ish tower)
========================== */
class Building {
  constructor(x, y, w=38, h=24, height=48, hue=210) {
    this.x = x; this.y = y;      // ground center
    this.w = w;  this.h = h;     // footprint
    this.height = height;        // visual height
    this.hue = hue + Math.floor(rand(-8,8));
    this.visitorsThisWindow = new Set(); // agents that dwelled here this window
  }
  draw3D(ctx) {
    // Simple “isometric-ish” prism using two slanted faces + top
    const x = this.x, y = this.y;
    const w = this.w, h = this.h, z = this.height;
    const sx = 0.6 * (w+h)/2; // slant x
    const sy = 0.4 * (w+h)/2; // slant y

    // Colors
    const base = `hsl(${this.hue} 30% 35%)`;
    const face = `hsl(${this.hue} 25% 28%)`;
    const side = `hsl(${this.hue} 22% 22%)`;
    const topc = `hsl(${this.hue} 35% 42%)`;
    const glow = ctx.createRadialGradient(x, y, 8, x, y, 100);
    glow.addColorStop(0, 'rgba(80,120,255,0.12)');
    glow.addColorStop(1, 'rgba(80,120,255,0)');

    // Ground glow
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.ellipse(x, y+8, w*1.6, h*1.4, 0, 0, Math.PI*2);
    ctx.fill();

    // Front face
    ctx.fillStyle = face;
    ctx.fillRect(x - w/2, y - h/2 - z, w, h + z);

    // Right slanted side
    ctx.fillStyle = side;
    ctx.beginPath();
    ctx.moveTo(x + w/2, y - h/2 - z);
    ctx.lineTo(x + w/2 + sx, y - h/2 - z - sy);
    ctx.lineTo(x + w/2 + sx, y + h/2 - sy);
    ctx.lineTo(x + w/2, y + h/2);
    ctx.closePath(); ctx.fill();

    // Top slanted
    ctx.fillStyle = topc;
    ctx.beginPath();
    ctx.moveTo(x - w/2, y - h/2 - z);
    ctx.lineTo(x + w/2, y - h/2 - z);
    ctx.lineTo(x + w/2 + sx, y - h/2 - z - sy);
    ctx.lineTo(x - w/2 + sx, y - h/2 - z - sy);
    ctx.closePath(); ctx.fill();

    // Outline for crispness
    ctx.strokeStyle = 'rgba(0,0,0,.35)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x - w/2, y - h/2 - z, w, h + z);
  }
}

/* ==========================
   Agent
========================== */
class Agent {
  constructor(x, y, infected=false) {
    this.x = x; this.y = y;
    // small random initial velocity so idle looks alive
    this.vx = rand(-0.7,0.7); this.vy = rand(-0.7,0.7);
    this.state = infected ? 'infected' : 'healthy'; // healthy | infected | immune
    this.timer = 0;                                  // frames in current state
    this.plan = [];                                  // [b0, b1] for the day
    this.targetIndex = 0;                            // 0 or 1 for windows
    this.mode = 'travel';                            // travel | dwell | drift
    this.dwellLeft = 0;
    this._taggedThisWindow = false;                  // added to building set already?
  }

  pickTwo(buildings){
    // two distinct buildings
    const b0 = buildings[Math.floor(rand(0, buildings.length))];
    let b1 = b0;
    while (b1 === b0) b1 = buildings[Math.floor(rand(0, buildings.length))];
    this.plan = [b0, b1];
    this.targetIndex = 0;
    this.mode = 'travel';
    this._taggedThisWindow = false;
  }

  currentTarget(){
    return this.plan.length ? this.plan[this.targetIndex] : null;
  }

  _seekTarget(target){
    if(!target) return;
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const d = Math.hypot(dx, dy) || 1;
    const sp = AGENT_SPEED;
    this.vx = (dx/d) * sp;
    this.vy = (dy/d) * sp;
    this.x += this.vx; this.y += this.vy;
  }

  update(buildings){
    // update state timers
    this.timer++;
    if (this.state === 'infected' && this.timer > SICK_FRAMES) {
      this.state = 'immune'; this.timer = 0;
    } else if (this.state === 'immune' && this.timer > IMMUNE_FRAMES) {
      this.state = 'healthy'; this.timer = 0;
    }

    // behaviors
    if (this.mode === 'travel') {
      const t = this.currentTarget();
      this._seekTarget(t);
      if (t && dist2(this.x, this.y, t.x, t.y) < ARRIVE_DIST*ARRIVE_DIST) {
        this.mode = 'dwell';
        this.dwellLeft = DWELL_FRAMES;
      }
    } else if (this.mode === 'dwell') {
      // slight idle wiggle
      this.x += this.vx*0.05; this.y += this.vy*0.05;
      this.dwellLeft--;
      if (this.dwellLeft <= 0) {
        // stay nearby but start drifting while the window runs
        this.mode = 'drift';
      }
    } else if (this.mode === 'drift') {
      // small random walk around the area
      this.vx += rand(-0.1, 0.1); this.vy += rand(-0.1, 0.1);
      this.vx = clamp(this.vx, -0.8, 0.8);
      this.vy = clamp(this.vy, -0.8, 0.8);
      this.x += this.vx; this.y += this.vy;
    }

    // keep on canvas
    this.x = clamp(this.x, 6, sim.width-6);
    this.y = clamp(this.y, 6, sim.height-6);
  }

  draw(ctx){
    ctx.beginPath();
    if (this.state === 'healthy') ctx.fillStyle = 'lime';
    if (this.state === 'infected') ctx.fillStyle = '#ff4b4b';
    if (this.state === 'immune')  ctx.fillStyle = '#4aa3ff';
    ctx.arc(this.x, this.y, 5.5, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ==========================
   World Setup
========================== */
const buildings = [];
// Grid buildings (nicely spaced, random heights)
const cols = 6, rows = 3;
const gx0 = CITY_PADDING, gx1 = sim.width - CITY_PADDING;
const gy0 = CITY_PADDING+40, gy1 = sim.height - CITY_PADDING-40;
for (let r=0; r<rows; r++){
  for (let c=0; c<cols; c++){
    const x = gx0 + (gx1 - gx0) * (c/(cols-1));
    const y = gy0 + (gy1 - gy0) * (r/(rows-1));
    buildings.push(new Building(x, y, 42, 28, rand(40, 90), 208));
  }
}

const agents = [];
for (let i=0; i<N_AGENTS; i++){
  const infected = Math.random() < START_INFECTED;
  const a = new Agent(rand(80, sim.width-80), rand(80, sim.height-80), infected);
  agents.push(a);
}

/* ==========================
   Day/Window Scheduling
========================== */
let frame = 0;
let day = 0;
let windowIndex = 0; // 0 or 1

function startDay(){
  day++;
  windowIndex = 0;
  for (const b of buildings) b.visitorsThisWindow.clear();
  for (const a of agents) {
    a.pickTwo(buildings);
    a.mode = 'travel';
    a._taggedThisWindow = false;
  }
  pushChartPoint(); // record day 0 counts immediately, then daily
}

function startWindow(){
  // new window begins; agents target current index (0 or 1)
  for (const b of buildings) b.visitorsThisWindow.clear();
  for (const a of agents) {
    a._taggedThisWindow = false;
    a.mode = 'travel';
    a.dwellLeft = 0;
  }
}

function endWindowProcessInfections(){
  // For each building: if any infected visited this window,
  // each healthy visitor has 1% chance to get infected (once per window).
  for (const b of buildings) {
    if (b.visitorsThisWindow.size === 0) continue;
    let anyInfected = false;
    for (const ag of b.visitorsThisWindow) {
      if (ag.state === 'infected') { anyInfected = true; break; }
    }
    if (anyInfected) {
      for (const ag of b.visitorsThisWindow) {
        if (ag.state === 'healthy' && Math.random() < INFECT_CHANCE) {
          ag.state = 'infected';
          ag.timer = 0;
        }
      }
    }
  }
}

/* ==========================
   Chart
========================== */
const chartCtx = document.getElementById('chart').getContext('2d');
const chartData = {
  labels: [],
  datasets: [
    { label: 'Healthy',  data: [], borderColor: 'lime',   fill: false, tension: 0.15 },
    { label: 'Infected', data: [], borderColor: '#ff4b4b', fill: false, tension: 0.15 },
    { label: 'Immune',   data: [], borderColor: '#4aa3ff', fill: false, tension: 0.15 },
  ]
};
const simChart = new Chart(chartCtx, { type: 'line', data: chartData, options: {
  animation: false, responsive: true, maintainAspectRatio: false,
  scales: { y: { beginAtZero: true, suggestedMax: N_AGENTS } },
  plugins: { legend: { labels: { color: '#d7dbea' } } }
}});

function pushChartPoint(){
  const h = agents.filter(a=>a.state==='healthy').length;
  const i = agents.filter(a=>a.state==='infected').length;
  const m = agents.filter(a=>a.state==='immune').length;
  chartData.labels.push(String(day));
  chartData.datasets[0].data.push(h);
  chartData.datasets[1].data.push(i);
  chartData.datasets[2].data.push(m);
  simChart.update();
}

/* ==========================
   Main Loop
========================== */
function loop(){
  // Background/grid
  ctx.clearRect(0,0,sim.width,sim.height);
  drawGroundGrid();

  // Buildings
  for (const b of buildings) b.draw3D(ctx);

  // Agents
  for (const a of agents) {
    a.update(buildings);

    // Tag visit if dwelling inside building during this window
    const t = a.currentTarget();
    if (t) {
      // Consider “inside” if close to footprint center OR still dwelling
      const near = dist2(a.x, a.y, t.x, t.y) < (ARRIVE_DIST*ARRIVE_DIST*1.2);
      if ((a.mode === 'dwell' || near) && !a._taggedThisWindow) {
        t.visitorsThisWindow.add(a);
        a._taggedThisWindow = true;
      }
    }
    a.draw(ctx);
  }

  // Time & window switching
  frame++;
  // window boundaries
  const inWindowFrame = frame % WINDOW_FRAMES;
  if (inWindowFrame === 0) {
    // end previous window (except very first tick)
    if (frame > 0) {
      endWindowProcessInfections();
      windowIndex++;
      if (windowIndex >= WINDOWS_PER_DAY) {
        // End of day
        pushChartPoint();
        startDay();
      } else {
        // Switch to second window (targetIndex = 1)
        for (const a of agents) a.targetIndex = 1;
        startWindow();
      }
    }
  }

  requestAnimationFrame(loop);
}

function drawGroundGrid(){
  ctx.save();
  ctx.strokeStyle = 'rgba(128,148,200,0.08)';
  ctx.lineWidth = 1;
  const step = 40;
  for (let x = step/2; x < sim.width; x+=step) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, sim.height); ctx.stroke();
  }
  for (let y = step/2; y < sim.height; y+=step) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(sim.width, y); ctx.stroke();
  }
  ctx.restore();
}

/* ==========================
   Boot
========================== */
startDay();
startWindow();
loop();
</script>
</body>
</html>
